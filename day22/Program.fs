/// <summary>
/// Day 22: Monkey Market - Secret Number Trading Challenge
/// </summary>
/// <description>
/// Solves Advent of Code Day 22 challenge about predicting buyer behavior in a monkey market. 
/// The module analyzes pseudorandom sequences of secret numbers and price patterns to maximize banana trades.
/// </description>
///
/// <remarks>
/// <para>Problem details:</para>
/// <list type="bullet">
///   <item><description><b>Input:</b> Initial secret numbers for each buyer in the Monkey Exchange Market</description></item>
///   <item><description><b>Part 1:</b> Calculate sum of 2000th secret number generated by each buyer's algorithm</description></item>
///   <item><description><b>Part 2:</b> Find optimal price pattern to maximize banana trades across all buyers</description></item>
/// </list>
/// 
/// <para>Each secret number evolves through a three-step process:</para>
/// <list type="bullet">
///   <item><description>Multiply by 64, mix (XOR), and prune (modulo 16777216)</description></item>
///   <item><description>Divide by 32, mix (XOR), and prune (modulo 16777216)</description></item>
///   <item><description>Multiply by 2048, mix (XOR), and prune (modulo 16777216)</description></item>
/// </list>
/// 
/// <para>The solution uses parallel processing and efficient data structures for performance optimization.</para>
/// 
/// See: <see href="https://adventofcode.com/2024/day/22">Advent of Code 2024, Day 22</see>
/// </remarks>


module day22

open System.Diagnostics
open NUnit.Framework
open FsUnit

/// <summary>
/// Mixes a value into the secret number using XOR operation
/// </summary>
let mix value secret = value ^^^ secret


/// <summary>
/// Prunes the secret number by taking modulo 16777216
/// </summary>
let prune secret = secret % 16777216L


/// <summary>
/// Generates the next secret number in the sequence using the monkey's algorithm
/// </summary>
let next secret =
    let secret = secret |> mix (secret * 64L) |> prune
    let secret = secret |> mix (secret / 32L) |> prune
    secret |> mix (secret * 2048L) |> prune


/// <summary>
/// Calculates the sum of the 2000th secret number for each buyer in the Monkey Exchange Market.
/// </summary>
/// <remarks>
/// <para>For each buyer's initial secret number, the function:</para>
/// <list type="number">
///   <item><description>Generates 2000 new secret numbers using the monkey's algorithm</description></item>
///   <item><description>Takes the 2000th number in the sequence</description></item>
///   <item><description>Sums these numbers across all buyers</description></item>
/// </list>
///
/// <para>The secret number evolution follows these steps:</para>
/// <list type="bullet">
///   <item><description>Multiply by 64, mix, and prune</description></item>
///   <item><description>Divide by 32, mix, and prune</description></item>
///   <item><description>Multiply by 2048, mix, and prune</description></item>
/// </list>
/// </remarks>
/// <param name="initialSecrets">Array of initial secret numbers from each buyer</param>
/// <returns>Sum of the 2000th secret number from each buyer's sequence</returns>
let part1 (initialSecrets: int64[]) =
    // Pre-allocate the array with zeros - more efficient than copying
    let mutable sum = 0L

    // Compute the sequence in place
    for i = 0 to initialSecrets.Length - 1 do
        let mutable current = initialSecrets[i]

        for _ = 1 to 2000 do
            current <- next current

        sum <- sum + current

    sum



/// <summary>
/// Finds the optimal price pattern in the Monkey Exchange Market to maximize banana trades.
/// </summary>
/// <remarks>
/// <para>Algorithm steps:</para>
/// <list type="number">
///   <item><description>Generate price sequences (0-9) for each buyer's next 2000 secret numbers</description></item>
///   <item><description>Calculate price changes between consecutive numbers</description></item>
///   <item><description>Find patterns of 4 consecutive price changes</description></item>
///   <item><description>Track total banana prices for each unique pattern</description></item>
///   <item><description>Return the maximum possible banana price achievable</description></item>
/// </list>
///
/// <para>Price patterns are tracked as 4-tuples of consecutive price changes.
/// Each change represents the difference between consecutive prices.
/// The function uses parallel processing for generating sequences and changes.</para>
/// </remarks>
/// <param name="initialSecrets">Array of initial secret numbers from each buyer</param>
/// <returns>Maximum number of bananas obtainable using the optimal price change pattern</returns>
let part2 (initialSecrets: int64[]) =
    // Create sequences of price digits (0-9) for each initial secret
    let sequences =
        initialSecrets
        |> Array.Parallel.map (fun initial ->
            let numbers = Array.zeroCreate 2001
            numbers[0] <- initial % 10L

            // Compute the sequence in place
            let mutable current = initial

            for i in 1..2000 do
                current <- next current
                numbers[i] <- current % 10L

            numbers)

    let changes =
        sequences
        |> Array.Parallel.map (fun seq -> Array.init 2000 (fun i -> seq[i + 1] - seq[i]))

    // Use tuples instead of arrays for patterns (more efficient)
    let mutable patternMap = Map.empty<int64 * int64 * int64 * int64, int64>

    // Process each buyer's changes
    for buyerIdx = 0 to changes.Length - 1 do
        let mutable seenPatterns = Set.empty

        // Find patterns
        for i = 0 to changes[buyerIdx].Length - 4 do
            let pattern =
                changes[buyerIdx].[i], changes[buyerIdx].[i + 1], changes[buyerIdx].[i + 2], changes[buyerIdx].[i + 3]

            if not (seenPatterns.Contains pattern) then
                let nextPrice = sequences[buyerIdx].[i + 4]

                patternMap <-
                    match Map.tryFind pattern patternMap with
                    | None -> Map.add pattern nextPrice patternMap
                    | Some existing -> Map.add pattern (existing + nextPrice) patternMap

                seenPatterns <- Set.add pattern seenPatterns

    // Find maximum sum
    patternMap |> Map.values |> Seq.max



let parse (input: string) =
    input.Split("\n") |> Array.map (fun line -> line.TrimEnd() |> int64)

/// <summary>
/// Example test cases and assertions for the Monkey Market solution
/// </summary>
module Example =
    let input1 =
        "1
10
100
2024"

    let input2 =
        "1
2
3
2024"

    /// <summary>
    /// Tests the solution for part 1 of the Monkey Market challenge.
    /// </summary>
    /// <remarks>
    /// <para>Verifies that our algorithm correctly calculates the sum of the 2000th 
    /// secret number for each buyer in the example data.</para>
    /// 
    /// <para>The expected result is 37327623, representing the combined secrets from
    /// the buyers with initial secrets of:</para>
    /// <list type="bullet">
    ///   <item><description>1</description></item>
    ///   <item><description>10</description></item>
    ///   <item><description>100</description></item>
    ///   <item><description>2024</description></item>
    /// </list>
    /// </remarks>
    [<Test>]
    let testPart1 () =
        parse input1 |> part1 |> should equal 37327623L
    
    /// <summary>
    /// Tests the solution for part 2 of the Monkey Market challenge.
    /// </summary>
    /// <remarks>
    /// <para>Validates that our algorithm correctly identifies the optimal
    /// sequence of four price changes that maximizes the total number
    /// of bananas received from all buyers.</para>
    /// 
    /// <para>The expected result is 23, which represents the sum of bananas
    /// obtained by following the pattern <b>-2,1,-1,3</b> when selling
    /// hiding spots to buyers with initial secrets of:</para>
    /// <list type="bullet">
    ///   <item><description>1</description></item>
    ///   <item><description>2</description></item>
    ///   <item><description>3</description></item>
    ///   <item><description>2024</description></item>
    /// </list>
    /// </remarks>
    [<Test>]
    let testPart2 () =
        parse input2 |> part2 |> should equal 23L


/// <summary>Main entry point for the program</summary>
[<EntryPoint>]
let main _ =
    let input = stdin.ReadToEnd().TrimEnd()
    printfn $"Input length: %d{input.Length}"

    let initialSecrets = parse input |> Array.ofSeq // Convert to array once
    printfn $"Number of initial secrets: %d{initialSecrets.Length}"


    let stopwatch = Stopwatch()
    stopwatch.Start()

    initialSecrets |> part1 |> printfn "Part 1: %d"
    initialSecrets |> part2 |> printfn "Part 2: %d"

    stopwatch.Stop()

    printfn $"Elapsed time: %.4f{stopwatch.Elapsed.TotalSeconds} seconds"

    0
